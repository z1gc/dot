#!/usr/bin/env python3

# MOIS <> STOW

import argparse
import os
import shutil
from dataclasses import dataclass, field
from configparser import ConfigParser
import logging
import socket
from enum import Enum
from typing import List, Dict, DefaultDict
from collections import defaultdict

from trait import nongit


WORKING_DIR = os.path.dirname(os.path.realpath(__file__))
PACKAGE_DIR = os.path.join(WORKING_DIR, "stow")
MACHINE_DIR = os.path.join(WORKING_DIR, "machine")
SOURCE_DIR = os.path.join(WORKING_DIR, "fragment")


def source_directory(path: str) -> str:
    return os.path.join(SOURCE_DIR, path)


def target_directory(path: str) -> str:
    return os.path.expanduser(path)


@dataclass
class FileStatus:
    class Status(Enum):
        UNKNOWN = -1
        IDENTICAL = 0
        DIFFER = 1
        ONLY_LEFT = 2
        ONLY_RIGHT = 3

    source: str
    target: str
    status: Status


@dataclass
class MoisMeta:
    machine: str = socket.gethostname()
    specs: DefaultDict[str, List[ConfigParser]] = field(
        default_factory=lambda: defaultdict(list)
    )
    packages: DefaultDict[str, List[FileStatus]] = field(
        default_factory=lambda: defaultdict(list)
    )
    run_nongit: bool = False


def load_machine(machine: str, meta: MoisMeta) -> bool:
    # Read machine spec first:
    config = ConfigParser()
    config.read(os.path.join(MACHINE_DIR, machine))

    # For inherit, we read them recursively:
    for inherit in config._sections.get("inherit", dict()).values():
        if not load_machine(inherit, meta):
            return False

    # Fetch all specifications, including the prefixes, stores to meta for speedups:
    if len(meta.specs) == 0:
        for workdir, _, files in os.walk(PACKAGE_DIR):
            for package in files:
                comp = package.split(".")
                assert len(comp) == 1 or len(comp) == 2

                spec = os.path.join(workdir, package)
                pkgconfig = ConfigParser()
                pkgconfig.read(spec)

                if len(comp) == 2:
                    meta.specs[comp[0]].append(pkgconfig)
                meta.specs[package].append(pkgconfig)

    # Load the required packages from spec, to meta
    for package in config._sections["package"].values():
        file_status = meta.packages[package]

        for pkgconfig in meta.specs[package]:
            if pkgconfig.get("package", "type") == "nongit":
                continue

            source = source_directory(pkgconfig.get("package", "source"))
            target = target_directory(pkgconfig.get("package", "target"))

            for workdir, dirs, files in os.walk(source):
                if len(dirs) != 0:
                    continue

                # Only count for files:
                for file in files:
                    left = os.path.join(workdir, file)
                    right = os.path.join(target, left.removeprefix(source)[1:])

                    file_status.append(
                        FileStatus(left, right, FileStatus.Status.UNKNOWN)
                    )

    # Dump for testing:
    for package, file_status in meta.packages.items():
        print(package)
        for status in file_status:
            print(status.source, "->", status.target)


load_machine("evil", MoisMeta())


def run_nongit(config: ConfigParser) -> bool:
    assert config.get("package", "type") == "nongit"

    source = config.get("package", "source")
    target = config.get("package", "target")
    target = source_directory(target)
    includes = [v for _, v in config._sections["include"].items()]

    meta = nongit.NongitMeta(
        source,
        config.get("package", "branch"),
        config.get("package", "rev", fallback=None),
        includes,
    )

    logging.info("Running nongit for %s...", target)
    rev = nongit.update(target, meta)
    if rev is None:
        return False

    config.set("package", "rev", rev)
    return True
