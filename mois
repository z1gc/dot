#!/usr/bin/env python3

# MOIS <> STOW
# TODO: Rewritten in Rust, as a more generic module,
#       e.g.
#       - For manage the "outside" files in the repo, it can be in network as well.
#       - Git-compatible, can use tools like 'magit' to view diffs or resolve conflicts.
#       - Support hooks.

import argparse
import os
import sys
import shutil
from configparser import ConfigParser, NoSectionError
import logging
import socket
from enum import Enum
from typing import List, Dict, DefaultDict, Optional, Tuple
from collections import defaultdict
import filecmp
import subprocess


def should_log_debug() -> bool:
    return logging.root.getEffectiveLevel() <= logging.DEBUG


HOME_DIR = os.path.expanduser("~")
THIS_SCRIPT = os.path.realpath(__file__)
WORKING_DIR = os.path.dirname(THIS_SCRIPT)
PACKAGE_DIR = os.path.join(WORKING_DIR, "stow")
MACHINE_DIR = os.path.join(WORKING_DIR, "machine")
SOURCE_DIR = os.path.join(WORKING_DIR, "super")
NONGIT_DIR = os.path.join(WORKING_DIR, "party")


def pretty_print_path(source: str) -> str:
    """
    Input:
      global(SOURCE_DIR) for removeprefix
      global(NONGIT_DIR) for removeprefix
      global(HOME_DIR) for removeprefix
    """

    if source.startswith(SOURCE_DIR):
        return "S" + source.removeprefix(SOURCE_DIR)
    elif source.startswith(NONGIT_DIR):
        return "P" + source.removeprefix(NONGIT_DIR)
    elif source.startswith(HOME_DIR):
        return "~" + source.removeprefix(HOME_DIR)
    else:
        return source


class FileStatus:
    class Status(Enum):
        IDENTICAL = 0
        DIFFER = 1
        ONLY_LEFT = 2

    filter: Optional[str]
    source: str
    target: str
    status: Status

    def __init__(self, left: str, right: str):
        self.source = left
        self.target = right

        # Should compare two files:
        left_exists = os.path.isfile(left)
        right_exists = os.path.isfile(right)
        assert left_exists

        if right_exists:
            if filecmp.cmp(left, right):
                self.status = FileStatus.Status.IDENTICAL
            else:
                # TODO: Permission differ:
                self.status = FileStatus.Status.DIFFER
        else:
            self.status = FileStatus.Status.ONLY_LEFT


class MoisMeta:
    machine: str

    # TODO: python3.12 introduces 'type' keyword:
    Specs = Dict[str, Tuple[str, ConfigParser]]
    specs: Specs

    FileList = DefaultDict[str, List[FileStatus]]
    filelist: FileList

    dry_run: bool
    force: bool


def load_specs() -> Optional[MoisMeta.Specs]:
    """
    Input: global(PACKAGE_DIR) for os.walk
    """

    specs: MoisMeta.Specs = dict()

    # TODO: USE flag like gentoo? It may needs redesign...
    for workdir, _, files in os.walk(PACKAGE_DIR):
        for package in files:
            if package in specs:
                logging.error("Duplicate package %s, cannot continue!", package)
                return None

            spec = os.path.join(workdir, package)
            pkgconfig = ConfigParser()
            pkgconfig.read(spec)
            specs[package] = (spec, pkgconfig)

    return specs


def load_filelist(machine: str, specs: MoisMeta.Specs) -> Optional[MoisMeta.FileList]:
    """
    Input:
      global(MACHINE_DIR) for ConfigParser
      global(SOURCE_DIR) for os.walk
    """

    filelist: MoisMeta.FileList = defaultdict(list)

    def load_one(this_machine: str) -> bool:
        # Read machine spec first:
        config = ConfigParser()
        config.read(os.path.join(MACHINE_DIR, this_machine))

        # For inherit, we read them recursively:
        try:
            for inherit in [v for _, v in config.items("inherit")]:
                if not load_one(inherit):
                    return False
        except NoSectionError:
            pass

        try:
            packages = [v for _, v in config.items("package")]
        except NoSectionError:
            packages = []

        for package in packages:
            file_status: List[FileStatus] = filelist[package]

            def walk_files(source: str, target: str) -> None:
                for workdir, dirs, files in os.walk(source):
                    # Only count for files:
                    for file in files:
                        left = os.path.join(workdir, file)

                        # For target, we should convert 'dot-' to '.' as stow does
                        right = left.replace("/dot-", "/.")
                        right = right.removeprefix(source)[1:]
                        right = os.path.join(target, right)

                        file_status.append(FileStatus(left, right))

            # Load package itselfs:
            # TODO: resolve root target, e.g. '/etc'
            walk_files(os.path.join(SOURCE_DIR, package), HOME_DIR)

            # Load nongit dependencies:
            _, pkgconfig = specs[package]
            for section in pkgconfig.sections():
                name = get_nongit_name(section)
                if name is None:
                    continue

                target = os.path.expanduser(pkgconfig.get(section, "target"))
                walk_files(os.path.join(NONGIT_DIR, package, name), target)

        return True

    if not load_one(machine):
        return None

    return filelist


def nongit_update(path: str, config: Dict[str, str], dry_run: bool) -> bool:
    """
    Input: global(NONGIT_DIR) for subprocess
    Output: config["rev"] if success
    """

    # From config:
    workdir = os.path.join(NONGIT_DIR, path)
    repo = config["repo"]
    branch = config["branch"]
    checkout = config.get("checkout", "").split()
    exclude = config.get("exclude", "").split()
    rev = config.get("rev", None)

    # Prepare workdir, clean it up, TODO: dry_run?
    if not dry_run and os.path.isdir(workdir):
        logging.debug("Removing workdir %s", path)
        shutil.rmtree(workdir)
    os.makedirs(workdir, exist_ok=True)

    def git(dry_run: bool, *args: str) -> bytes:
        if dry_run:
            logging.info("Run: 'git %s' in %s", " ".join(args), workdir)
            return b""
        else:
            return subprocess.check_output(["git"] + list(args), cwd=workdir)

    # Fetch latest commit of the branch:
    heads = git(False, "ls-remote", repo, f"refs/heads/{branch}").splitlines()
    if len(heads) != 1:
        logging.error("Cannot match the exact branch!")
        return False

    head = heads[0].split()[0].decode("ascii")
    if rev is not None and rev == head:
        logging.info("Already up-to-date, skipped.")
        return True
    config["rev"] = head

    # A dumb way to update, as git-r3 in gentoo:
    git(dry_run, "init")
    git(dry_run, "fetch", "--depth=1", repo, head)
    if len(checkout) != 0:
        args = ["--", *checkout]
    else:
        args = []
    git(dry_run, "checkout", "FETCH_HEAD", *args)
    logging.info("Nongit: %s at %s", workdir, head)

    # Clean the excluded files, if any:
    for path in exclude:
        fullpath = os.path.join(workdir, path)

        if dry_run:
            logging.info("Run: rm %s", fullpath)
        elif os.path.isfile(fullpath):
            os.unlink(fullpath)
        else:
            shutil.rmtree(os.path.join(workdir, path))

    # Clear the '.git' directory we don't want:
    if not dry_run:
        shutil.rmtree(os.path.join(workdir, ".git"))

    return True


def get_nongit_name(key: str) -> Optional[str]:
    if not key.startswith("nongit/"):
        return None
    return key.split("/", 1)[-1]


def run_nongit(specs: MoisMeta.Specs, dry_run: bool, is_all: bool) -> bool:
    pkgconfig: ConfigParser

    for package, (spec, pkgconfig) in specs.items():
        # Search for "nongit/" key:
        for section in pkgconfig.sections():
            name = get_nongit_name(section)
            if name is None:
                continue

            if not (
                is_all or pkgconfig.getboolean(section, "autoupdate", fallback=True)
            ):
                # Autoupdate seems disabled, check if "rev" is ready:
                if pkgconfig.has_option(section, "rev"):
                    logging.info("Skip nongit %s/%s", package, name)
                    continue

            logging.info("Running nongit for %s/%s...", package, name)
            config = dict(pkgconfig.items(section))
            if not nongit_update(f"{package}/{name}", config, dry_run):
                logging.error("Fail to run nongit!")
                return False

            # Save back to the spec file:
            if not dry_run:
                pkgconfig.set(section, "rev", config["rev"])  # TODO: As return?
                with open(spec, "w") as writer:
                    pkgconfig.write(writer)

    return True


def run_status(filelist: MoisMeta.FileList) -> bool:
    """
    Input: meta.packages
    """

    # TODO: Python missing the flatten...
    for package, files in filelist.items():
        for status in files:
            ps = pretty_print_path(status.source)
            pt = pretty_print_path(status.target)

            match status.status:
                case FileStatus.Status.IDENTICAL:
                    logging.debug("%s: identical %s == %s", package, ps, pt)

                case FileStatus.Status.ONLY_LEFT:
                    logging.info("%s: missing %s -> %s", package, ps, pt)

                case FileStatus.Status.DIFFER:
                    logging.info("%s: differ %s -> %s", package, ps, pt)

                    # TODO: Use python library instead:
                    subprocess.call(
                        ["diff", "-u7", "--color", status.source, status.target]
                    )

    return True


def run_add(filelist: MoisMeta.FileList, files_add: List[str]) -> bool:
    # To speed a little up, TODO: make filelist a set:
    files_set = set(files_add)

    # TODO: Lazy load the filelist, only load for matched files:
    for package, files in filelist.items():
        for status in files:
            if status.status != FileStatus.Status.DIFFER:
                continue

            if status.target not in files_set:
                continue

            # TODO: For non-existance package, we shall create one:
            logging.info(
                "%s: add %s -> %s",
                package,
                pretty_print_path(status.target),
                pretty_print_path(status.source),
            )

            # TODO: With dry_run:
            shutil.copy2(status.target, status.source)
            files_set.remove(status.target)

    if len(files_set) != 0:
        for remain in files_set:
            logging.warning("skip useless file: %s", remain)
        return False

    return True


def run_apply(filelist: MoisMeta.FileList, dry_run: bool, force: bool) -> bool:
    copies = []

    for package, files in filelist.items():
        for status in files:
            if status.status == FileStatus.Status.IDENTICAL:
                continue

            ps = pretty_print_path(status.source)
            pt = pretty_print_path(status.target)

            confirm = True
            if status.status == FileStatus.Status.DIFFER:
                if not (force or dry_run):
                    logging.info("%s: differ %s -> %s", package, ps, pt)
                    confirm = True if input("overwrite? [y/n]:") == "y" else False

            if confirm:
                copies.append((package, status, ps, pt))

    def unlink_broken(link: str, pretty: str) -> None:
        if os.path.islink(link) and not os.path.exists(link):
            logging.debug("Run: unlink %s", pretty)
            os.unlink(link)

    for package, status, pretty_source, pretty_target in copies:
        # TODO: consider sudo
        if not dry_run:
            target_parent = os.path.dirname(status.target)
            if not os.path.isdir(target_parent):
                pp = pretty_print_path(target_parent)
                unlink_broken(target_parent, pp)

                logging.debug("Run: mkdir %s", pp)
                os.makedirs(target_parent)

            # Try unlink broken symbolic links, which will cause the copy2 fails:
            unlink_broken(status.target, pretty_target)

        logging.info("Run: cp %s -> %s", pretty_source, pretty_target)
        if not dry_run:
            shutil.copy2(status.source, status.target)

    return True


def parse_args(args: List[str]) -> argparse.Namespace:
    # main
    parser = argparse.ArgumentParser(prog="mois", description="Like stow just.")
    parser.add_argument("-v", "--verbose", help="show debug logs", action="store_true")
    parser.add_argument("-m", "--machine", help="specify machine", action="store")
    subparsers = parser.add_subparsers(help="how to cook")

    # TODO: init/config/add/rm

    # status
    parser_status = subparsers.add_parser("status")
    parser_status.set_defaults(op=True, status=True)

    # apply
    parser_apply = subparsers.add_parser("apply")
    parser_apply.set_defaults(op=True, apply=True)
    parser_apply.add_argument("--do", help="do it, for real", action="store_true")
    parser_apply.add_argument(
        "-f", "--force", help="without asking", action="store_true"
    )

    # add
    parser_add = subparsers.add_parser("add")
    parser_add.set_defaults(op=True, add=True)
    parser_add.add_argument(
        "files", metavar="file", type=str, nargs="+", help="files to add"
    )

    # nongit
    parser_status = subparsers.add_parser("pull")
    parser_status.set_defaults(op=True, nongit=True)
    parser_status.add_argument("--do", help="do it, for real", action="store_true")
    parser_status.add_argument(
        "--all",
        help="upgrade the non-autoupdate repositories as well",
        action="store_true",
    )

    # mypy
    parser_mypy = subparsers.add_parser("mypy")
    parser_mypy.set_defaults(op=True, mypy=True)

    # parse
    return parser.parse_args(args)


def main(args: List[str]) -> bool:
    namespace = parse_args(args)

    loglevel = logging.INFO
    if namespace.verbose:
        loglevel = logging.DEBUG
    logging.basicConfig(format="[%(levelname).1s] %(message)s", level=loglevel)

    if not getattr(namespace, "op", False):
        logging.error("Please specify a valid command! Use '--help' for commands.")
        return False

    # mypy check
    if getattr(namespace, "mypy", False):
        subprocess.check_call(["mypy", "--strict", THIS_SCRIPT])
        return True

    # entry
    meta = MoisMeta()

    specs = load_specs()
    if specs is None:
        logging.error("Reading specs failed!")
        return False
    meta.specs = specs

    meta.dry_run = not getattr(namespace, "do", False)

    if getattr(namespace, "nongit", False):
        # Fast-path to avoid loading the machine:
        is_all = getattr(namespace, "all", False)
        return run_nongit(meta.specs, meta.dry_run, is_all)

    meta.machine = namespace.machine
    if meta.machine is None:
        meta.machine = socket.gethostname()

    logging.debug("Loading machine %s...", meta.machine)
    filelist = load_filelist(meta.machine, meta.specs)
    if filelist is None:
        logging.error("Reading filelist failed!")
        return False
    meta.filelist = filelist

    if getattr(namespace, "status", False):
        return run_status(meta.filelist)

    if getattr(namespace, "add", False):
        return run_add(meta.filelist, namespace.files)

    meta.force = getattr(namespace, "force", False)
    if getattr(namespace, "apply", False):
        return run_apply(meta.filelist, meta.dry_run, meta.force)

    logging.error("Why here? What's wrong?")
    return False


if __name__ == "__main__":
    if main(sys.argv[1:]):
        exit(0)
    else:
        exit(1)
