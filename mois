#!/usr/bin/env python3

# MOIS <> STOW
# TODO: Rewritten in Rust, as a more generic module,
#       e.g.
#       - For manage the "outside" files in the repo, it can be in network as well.
#       - Git-compatible, can use tools like 'magit' to view diffs or resolve conflicts.
#       - Support hooks.

import argparse
import os
import sys
import shutil
from configparser import ConfigParser
import logging
import socket
from enum import Enum
from typing import List, Dict, DefaultDict, Optional
from collections import defaultdict
import filecmp
import subprocess


def should_log_debug():
    return logging.root.getEffectiveLevel() <= logging.DEBUG


HOME_DIR = os.path.expanduser("~")
WORKING_DIR = os.path.dirname(os.path.realpath(__file__))
PACKAGE_DIR = os.path.join(WORKING_DIR, "stow")
MACHINE_DIR = os.path.join(WORKING_DIR, "machine")
SOURCE_DIR = os.path.join(WORKING_DIR, "super")
NONGIT_DIR = os.path.join(WORKING_DIR, "party")


def pretty_print_path(source: str):
    """
    Input:
      global(SOURCE_DIR) for removeprefix
      global(NONGIT_DIR) for removeprefix
      global(HOME_DIR) for removeprefix
    """

    if source.startswith(SOURCE_DIR):
        return "S" + source.removeprefix(SOURCE_DIR)
    elif source.startswith(NONGIT_DIR):
        return "P" + source.removeprefix(NONGIT_DIR)
    elif source.startswith(HOME_DIR):
        return "~" + source.removeprefix(HOME_DIR)
    else:
        return source


class FileStatus:
    class Status(Enum):
        IDENTICAL = 0
        DIFFER = 1
        ONLY_LEFT = 2

    filter: Optional[str]
    source: str
    target: str
    status: Status

    def __init__(self, left, right):
        self.source = left
        self.target = right

        # Should compare two files:
        left_exists = os.path.isfile(left)
        right_exists = os.path.isfile(right)
        assert left_exists

        if right_exists:
            if filecmp.cmp(left, right):
                self.status = FileStatus.Status.IDENTICAL
            else:
                # TODO: Permission differ:
                self.status = FileStatus.Status.DIFFER
        else:
            self.status = FileStatus.Status.ONLY_LEFT


class MoisMeta:
    machine: str

    # TODO: python3.12 introduces 'type' keyword:
    Specs = Dict[str, ConfigParser]
    specs: Specs

    FileList = DefaultDict[str, List[FileStatus]]
    filelist: FileList

    dry_run: bool
    force: bool


def load_specs() -> Optional[MoisMeta.Specs]:
    """
    Input: global(PACKAGE_DIR) for os.walk
    """

    specs: MoisMeta.Specs = dict()

    # TODO: USE flag like gentoo? It may needs redesign...
    for workdir, _, files in os.walk(PACKAGE_DIR):
        for package in files:
            if package in specs:
                logging.error("Duplicate package %s, cannot continue!", package)
                return None

            spec = os.path.join(workdir, package)
            pkgconfig = ConfigParser()
            pkgconfig.read(spec)

            # TODO: Avoid the private field:
            pkgconfig._mois_realpath = spec
            specs[package] = pkgconfig

    return specs


def load_filelist(machine: str, specs: MoisMeta.Specs) -> Optional[MoisMeta.FileList]:
    """
    Input:
      global(MACHINE_DIR) for ConfigParser
      global(SOURCE_DIR) for os.walk
    """

    filelist: MoisMeta.FileList = defaultdict(list)

    def load_one(this_machine: str) -> bool:
        # Read machine spec first:
        config = ConfigParser()
        config.read(os.path.join(MACHINE_DIR, this_machine))

        # For inherit, we read them recursively:
        for inherit in config._sections.get("inherit", dict()).values():
            if not load_one(inherit):
                return False

        for package in config._sections.get("package", dict()).values():
            file_status: List[FileStatus] = filelist[package]

            def walk_files(source: str, target: str):
                for workdir, dirs, files in os.walk(source):
                    if len(dirs) != 0:
                        continue

                    # Only count for files:
                    for file in files:
                        left = os.path.join(workdir, file)

                        # For target, we should convert 'dot-' to '.' as stow does
                        right = left.replace("/dot-", "/.")
                        right = right.removeprefix(source)[1:]
                        right = os.path.join(target, right)

                        file_status.append(FileStatus(left, right))

            # Load package itselfs:
            # TODO: resolve root target, e.g. '/etc'
            walk_files(os.path.join(SOURCE_DIR, package), HOME_DIR)

            # Load nongit dependencies:
            pkgconfig = specs[package]
            for k, v in pkgconfig._sections.items():
                name = get_nongit_name(k)
                if name is None:
                    continue

                target = os.path.expanduser(v["target"])
                walk_files(os.path.join(NONGIT_DIR, package, name), target)

        return True

    if not load_one(machine):
        return None

    return filelist


def nongit_update(path: str, config: Dict[str, str], dry_run: bool) -> bool:
    """
    Input: global(NONGIT_DIR) for subprocess
    """

    # From config:
    workdir = os.path.join(NONGIT_DIR, path)
    repo = config["repo"]
    branch = config["branch"]
    checkout = config.get("checkout", "").split()
    exclude = config.get("exclude", "").split()
    rev = config.get("rev", None)

    # Prepare workdir, TODO: dry_run?
    if not os.path.isdir(workdir):
        os.makedirs(workdir)

    def git(dry_run: bool, *args: str):
        if dry_run:
            logging.info("Run: 'git %s' in %s", " ".join(args), workdir)
        else:
            return subprocess.check_output(["git"] + list(args), cwd=workdir)

    # Fetch latest commit of the branch:
    heads: bytes = git(False, "ls-remote", repo, f"refs/heads/{branch}")
    heads = heads.splitlines()
    if len(heads) != 1:
        logging.error("Cannot match the exact branch!")
        return False

    head = heads[0].split()[0].decode("ascii")
    if rev is not None and rev == head:
        logging.info("Already up-to-date, skipped.")
        return True
    config["rev"] = head

    # A dumb way to update, as git-r3 in gentoo:
    git(dry_run, "init")
    git(dry_run, "fetch", "--depth=1", repo, head)
    if len(checkout) != 0:
        args = ["--", *checkout]
    else:
        args = []
    git(dry_run, "checkout", "FETCH_HEAD", *args)
    logging.info("Nongit: %s at %s", workdir, head)

    # Clean the excluded files, if any:
    for path in exclude:
        fullpath = os.path.join(workdir, path)

        if dry_run:
            logging.info("Run: rm %s", fullpath)
        elif os.path.isfile(fullpath):
            os.unlink(fullpath)
        else:
            shutil.rmtree(os.path.join(workdir, path))

    # Clear the '.git' directory we don't want:
    if not dry_run:
        shutil.rmtree(os.path.join(workdir, ".git"))

    return True


def get_nongit_name(key: str) -> Optional[str]:
    if not key.startswith("nongit/"):
        return None
    return key.split("/", 1)[-1]


def run_nongit(specs: MoisMeta.Specs, dry_run: bool) -> bool:
    for package, pkgconfig in specs.items():
        # Search for "nongit/" key:
        for k, v in pkgconfig._sections.items():
            name = get_nongit_name(k)
            if name is None:
                continue

            logging.info("Running nongit for %s/%s...", package, name)
            if not nongit_update(f"{package}/{name}", v, dry_run):
                logging.error("Fail to run nongit!")
                return False

            # Save back to the spec file:
            if not dry_run:
                with open(pkgconfig._mois_realpath, "w") as writer:
                    pkgconfig.write(writer)

    return True


def run_status(filelist: MoisMeta.FileList) -> bool:
    """
    Input: meta.packages
    """

    # TODO: Python missing the flatten...
    for package, files in filelist.items():
        for status in files:
            ps = pretty_print_path(status.source)
            pt = pretty_print_path(status.target)

            match status.status:
                case FileStatus.Status.IDENTICAL:
                    logging.debug("%s: identical %s == %s", package, ps, pt)

                case FileStatus.Status.ONLY_LEFT:
                    logging.info("%s: missing %s -> %s", package, ps, pt)

                case FileStatus.Status.DIFFER:
                    logging.info("%s: differ %s -> %s", package, ps, pt)

                    # TODO: Use python library instead:
                    subprocess.call(
                        ["diff", "-u7", "--color", status.source, status.target]
                    )

    return True


def run_add(filelist: MoisMeta.FileList, files_add: List[str]):
    # To speed a little up, TODO: make filelist a set:
    files_add = set(files_add)

    # TODO: Lazy load the filelist, only load for matched files:
    for package, files in filelist.items():
        for status in files:
            if status.status != FileStatus.Status.DIFFER:
                continue

            if status.target not in files_add:
                continue

            # TODO: For non-existance package, we shall create one:
            logging.info(
                "%s: add %s -> %s",
                package,
                pretty_print_path(status.target),
                pretty_print_path(status.source),
            )

            # TODO: With dry_run:
            shutil.copy2(status.target, status.source)
            files_add.remove(status.target)

    if len(files_add) != 0:
        for remain in files_add:
            logging.warning("skip useless file: %s", remain)
        return False

    return True


def run_apply(filelist: MoisMeta.FileList, dry_run: bool, force: bool) -> bool:
    copies = []

    for package, files in filelist.items():
        for status in files:
            if status.status == FileStatus.Status.IDENTICAL:
                continue

            ps = pretty_print_path(status.source)
            pt = pretty_print_path(status.target)

            confirm = True
            if status.status == FileStatus.Status.DIFFER:
                if not (force or dry_run):
                    logging.info("%s: differ %s -> %s", package, ps, pt)
                    confirm = True if input("overwrite? [y/n]:") == "y" else False

            if confirm:
                copies.append((package, status, ps, pt))

    def unlink_broken(link: str, pretty: str):
        if os.path.islink(link) and not os.path.exists(link):
            logging.debug("Run: unlink %s", pretty)
            os.unlink(link)

    for package, status, pretty_source, pretty_target in copies:
        # TODO: consider sudo
        if not dry_run:
            target_parent = os.path.dirname(status.target)
            if not os.path.isdir(target_parent):
                pp = pretty_print_path(target_parent)
                unlink_broken(target_parent, pp)

                logging.debug("Run: mkdir %s", pp)
                os.makedirs(target_parent)

            # Try unlink broken symbolic links, which will cause the copy2 fails:
            unlink_broken(status.target, pretty_target)

        logging.info("Run: cp %s -> %s", pretty_source, pretty_target)
        if not dry_run:
            shutil.copy2(status.source, status.target)

    return True


def parse_args(args):
    # main
    parser = argparse.ArgumentParser(prog="mois", description="Like stow just.")
    parser.add_argument("-v", "--verbose", help="show debug logs", action="store_true")
    parser.add_argument("-m", "--machine", help="specify machine", action="store")
    subparsers = parser.add_subparsers(help="how to cook")

    # TODO: init/config/add/rm

    # status
    parser_status = subparsers.add_parser("status")
    parser_status.set_defaults(op=True, status=True)

    # apply
    parser_apply = subparsers.add_parser("apply")
    parser_apply.set_defaults(op=True, apply=True)
    parser_apply.add_argument("--do", help="do it, for real", action="store_true")
    parser_apply.add_argument(
        "-f", "--force", help="without asking", action="store_true"
    )

    # add
    parser_add = subparsers.add_parser("add")
    parser_add.set_defaults(op=True, add=True)
    parser_add.add_argument(
        "files", metavar="file", type=str, nargs="+", help="files to add"
    )

    # nongit
    parser_status = subparsers.add_parser("pull")
    parser_status.set_defaults(op=True, nongit=True)
    parser_status.add_argument("--do", help="do it, for real", action="store_true")

    # parse
    return parser.parse_args(args)


def main(args):
    namespace = parse_args(args)

    loglevel = logging.INFO
    if namespace.verbose:
        loglevel = logging.DEBUG
    logging.basicConfig(format="[%(levelname).1s] %(message)s", level=loglevel)

    if not getattr(namespace, "op", False):
        logging.error("Please specify a valid command! Use '--help' for commands.")
        return False

    # entry
    meta = MoisMeta()

    meta.specs = load_specs()
    if meta.specs is None:
        logging.error("Reading specs failed!")
        return False

    meta.dry_run = not getattr(namespace, "do", False)

    if getattr(namespace, "nongit", False):
        # Fast-path to avoid loading the machine:
        return run_nongit(meta.specs, meta.dry_run)

    meta.machine = namespace.machine
    if meta.machine is None:
        meta.machine = socket.gethostname()

    logging.debug("Loading machine %s...", meta.machine)
    meta.filelist = load_filelist(meta.machine, meta.specs)

    if getattr(namespace, "status", False):
        return run_status(meta.filelist)

    if getattr(namespace, "add", False):
        return run_add(meta.filelist, namespace.files)

    meta.force = getattr(namespace, "force", False)
    if getattr(namespace, "apply", False):
        return run_apply(meta.filelist, meta.dry_run, meta.force)

    logging.error("Why here? What's wrong?")
    return False


if __name__ == "__main__":
    if main(sys.argv[1:]):
        exit(0)
    else:
        exit(1)
